# 动态规划之背包问题

## 背包问题分类

- 01背包：即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包
- 完全背包：完全背包又是也是01背包稍作变化而来，即完全背包的物品数量是无限的
- 多重背包

### 界定背包问题

![img](背包问题.assets/20210117171307407.png)

**背包问题的理论基础重中之重是01背包，一定要理解透！**



## 0-1 背包问题

### 问题描述

有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i]，价值是 value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

<img src="背包问题.assets/20210117175428387.jpg" alt="动态规划-背包问题" style="zoom:33%;" />

### 解决方案1（二维dp）

**定义状态转移数组 $dp[i][j]$ ，表示**下标为[0-i]的物品里任意取**，背包限制重量为 j 的情况下能装的最大价值。**

例如，$dp[3][4]=6$，表示用前3个物品装入重量为4的背包所能获得的最大价值为6，此时并不是3个物品全部装入，而是3个物品满足装入背包的条件下的最大价值。

#### 确定递推公式

有两个方向可以得到$dp[i][j]$，

- **不放物品i**：由$dp[i - 1$][j]推出，即背包容量为 j，里面不放物品i的最大价值，此时$dp[i][j]$就是$dp[i - 1$][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
- **放物品i**：由$dp[i - 1][j - weight[i]]$推出，$dp[i - 1][j - weight[i]] $为背包容量为j - weight[i]的时候不放物品i的最大价值，那么$dp[i - 1][j - weight[i]] + value[i]$ （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式：$ dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$

```C++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}
```

### 解决方案2（一维dp）

基于解决方案1，对于背包问题其实状态都是可以压缩的；也就是使用滚动数组

在使用二维数组的时候，递推公式：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：$dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])$**

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

所以递归公式为：

```
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

#### 确定遍历顺序

二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

`这是为了确保旧值在未使用前不被覆盖`

```C++
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}
```



### 题目转化为01背包

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

题目描述：给你一个 **只包含正整数** 的 **非空** 数组 nums  请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```C++
class Solution {
public:
    // 特点1：每个元素只能选择一次；特点2：背包容量为数组中值的总和的1/2；
    // 所以：每个物品的价值为数组中每个元素的数值；每个物品的质量也是数组中每个元素的数值，因此将其转换01背包问题
    bool canPartition(vector<int>& nums) {
        // 直接选取解决方案2（一维dp）,dp[j]表示背包容量为 j 的情况下能构成的子集和的最大值
        int sum = 0;
        for(auto it : nums){
            sum += it;
        }
        if(sum % 2 != 0) return false;
        int W = sum / 2;

        // 初始化dp[j]
        vector<int> dp(W + 1, 0);
        for(int i = 0; i < nums.size(); ++i){
            for(int j = W; j >= nums[i]; --j){
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        if(dp[W] == W) return true;
        return false;
    }
};
```

`注`

1. 把题目往背包问题进行转换的时候，要考虑的问题是，在转换后的问题中，背包容量是是么，每个物体的质量是是么，每个物体的价值是多少以及最后要求解的原问题和最大背包价值之间存在什么样的联系

2. 针对上述具体问题：
   1. 背包的体积为sum / 2
   2. 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
   3. 背包如果正好装满，说明找到了总和为 sum / 2 的子集（转换关系）

3. coding方面，需要注意的是这个条件 

   ```
   for(int j = W; j >= nums[i]; --j)
   ```

   
